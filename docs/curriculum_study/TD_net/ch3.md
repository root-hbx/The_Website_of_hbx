# Chapter3 传输层
## 3.1 简介

运输层协议为运行在不同主机上的应用进程之间提供了**逻辑通信**。

> 逻辑通信，不相连的主机像仿佛相连一样，可以直接通信。

运输层协议实现在端系统中。运输层将从发送**应用程序**进程收到的报文转换成**运输层分组**（**报文段**），**网络层**将报文段封装称**数据报**，向目的地发送。
网络路由器仅作用于该数据报的网络层字段。

## 3.1.1 运输层与网络层的关系

网络层提供了**主机之间**的逻辑通信。

运输层为运行在不同主机上的**进程之间**提供了逻辑通信。

## 3.1.2 因特网运输层概述

## 运输层协议

UDP（用户数据报协议）

- 不可靠、无连接

TCP（传输控制协议）

- 可靠、面向连接

## **TCP**

TCP服务可以提供：

1。面向连接的服务

- 建立TCP连接在两个通信进程的套接字之间。
- 该连接全双工，报文发送结束拆除连接。

2。可靠数据传输服务

- 传输保证

- 无差错
- 按适当顺序交付
- 无字节的丢失和冗余

  

3。拥塞控制

网络出现拥塞时，抑制发送端发送数据，改善网络环境

## **UDP**

仅提供了最小服务的轻量级运输协议，提供无连接、不可靠、不保证顺序的数据传输服务，且没有拥塞控制机制。

UDP可以选定任何速率向网络层注入数据。

## 网络层协议

IP（网际协议）

- 服务模型：尽力而为交付服务，IP尽其最大努力，在通信的主机之间交付报文段，但不做任何确保：

1. 不确保报文段是否能交付
2. 不确保按序交付

  

- 可靠性：不可靠
- 唯一性：每台主机只有一个IP地址

## 3.2 多路复用&多路分解

UDP和TCP的基本职责：

将**端系统之间（主机之间）**IP的交付服务拓展为运行在端系统上的**两个进程之间**的交付服务，这个又被称为**运输层的多路复用&多路分解**。

> 多路复用&多路分解即一种职责，是运输层协议的基本责任。

**多路分解**：将运输层报文段中的**数据**交付到**正确的套接字**的工作。

**多路复用**：

- 从源主机的不同套接字中收集数据块
- 并为每个数据块封装上首部信息，从而生成报文段
- 再传递至网络层

如果要满足多路复用&多路分解则需要：

1. 套接字有唯一标识符
2. 每个报文段要能指出被交付到的套接字

于是在报文中，我们通过增加**源端口号**、**目的端口号**来进行标识，每个字段16bits，大小在0-65535。

## 无连接的多路复用&多路分解

一个UDP的套接字是由一个二元组来标识的，这个二元组包含**目的IP地址**和**目的端口号**，不同的源端口发送的信息，只要目的IP地址与端口一致，将会被送到同一进程。

源端口号用于回传信息，是返回地址的一部分。

## 面向连接的多路复用&多路分解

TCP的套接字是一个四元组，包括**目的IP地址**，**目的端口号**，**源IP地址**和**源端口号**。

两个不同源相同目的地址的报文段将被定位到不同的套接字，除非TCP报文段携带了初始创建连接的请求。

## 3.3 无连接运输：UDP

相比较于IP协议，UDP提供了多一点的复用分解服务，以便网络层与正确的应用进程之间传递数据（可以定位到给那个应用程序）。

使用过程：

- 从应用程序获得数据
- 封装上源、目的端口号
- 将报文段交给网络层

UDP优点：

- 可以较为精细的控制传输传输时间，相比较于TCP而言
- 无需建立连接
- 不需要维护连接状态
- 首部开销小（TCP报文段首部开销20字节，UDP报文段首部开销8字节）

## 3.3.1 报文段结构

UDP首部四个字段，每个字段2个字节。

  

![](https://pic2.zhimg.com/80/v2-910613b1de91d55b62156013f8acb7e5_1440w.webp)

  

- 源端口号
- 目的端口号
- 长度

长度字段指示了UDP报文段中的字节数（首部+数据）

- 检验和

检验是否出现差错

## 3.3.2 检验和

略

## 3.4 可靠数据传输原理

这里研究，如何借助不可靠的协议构建一个可靠的传输信道。《计算机网络》书提出了几种协议，逐步推导出一个可靠的传输协议。该书上使用代码进行表示，《自顶向下》使用FSM（有限状态机）表示。

《计算机网络》（即教材中）总共构建了6种协议，这里都会涉及。

## 3.4.1 构建可靠数据传输协议

## 协议1：理想状态下完全可靠的数据传输

在这个协议中,数据只能单向传输。发送方和接收方的网络层总是处于准备就绪 状态。数据处理的时间忽略不计。可用的缓存空间无穷大。最强的一个条件是数据链路层 之间的通信信道永远不会损坏帧或者丢失帧。这个完全不现实的协议我们给它一个昵称“乌托邦”( Utopia)

  

![](https://pic3.zhimg.com/80/v2-95aa8876433eff89cc453c7bc9871252_1440w.webp)

  

## 协议2：无错信道上的单工停-等式协议

**处理这样的问题:**

发送方以高于接收方能处理到达帧的速度发送帧，导致接收方被淹没。这种情形实际上很容易出现，因此协议是否能够防止它非常重要。

然而, 我们仍然假设通信信道不会出错，并且数据流量还是单工的。

**解决方案：**

1. 建立足够强大的接收器,使其强大到能处理一个接着一个帧组成的连续流。
2. **让接收方给发送方提供反馈信息**。接收方将数据包传递给网络层之后给发送方返回一个小的哑帧，实际上这一帧的作用是给发送方一个许可，允许它发送下一帧。发送方在发出一帧之后，根据协议要求，它必须等待一段时间直到短哑帧（即确认）到达。

发送方发送一帧，等待对方确认到达后才能继续发送,这样的协议称为停·等式协议

  

![](https://pic3.zhimg.com/80/v2-84c3727a2e4e0fb65f7f4684e0074df6_1440w.webp)

  

  

## 协议3：有错信道上的单工停-等式协议

**常见问题的情形：**

通信信道可能会出错。帧可能会被**损坏**，也可能完全**被丢失**。然而，我们假设，如果一帧在传输过程中被损坏，则接收方硬件在计算校验和时能检测出来。

如果一帧被损坏了之后校验和仍然是正确的（**数据错误但是没能检测出**），那么这个协议（以及所有其他的协议）将会失败（即给网络层递交了一个不正确的数据包）。

**重申**：

- 数据链路层目标：

机器A上的网络层将数据交给A的数据链路层，想要把数据传递给机器B。

**数据链路层**A必须将数据包**丝毫不差**地传递给数据链路层B，并由它传递给机器B的网络层。

丝毫不差：

- 错包
- 重复
- 丢失

  

**协议待解决问题**

- 包完整性确认

采用接收端返回确认帧进行确认的方式。

- 确认帧的防丢失处理

**解决方案：**

在一个协议中，**发送方**在发送下一个数据之前必须**等待一个肯定确认**。

> 这样的协议称为**自动重复请求**( ARQ , Automatic Repeat reQuest)或**带有重传的肯定确认**( PAR, Positive Acknowledgement with Retransmission)。

  

![](https://pic1.zhimg.com/80/v2-09651469e9cd6882e1539ca1e46cbccc_1440w.webp)

  

  

![](https://pic2.zhimg.com/80/v2-5cc1170817874f30625ab49b4270b299_1440w.webp)

  

- 帧序号

帧序号只有0和1。原因是，发送一个帧是建立在前一个帧已经发送的情况下的，比如目前已经接收到了序号为0的帧，目标接收是序号为1的新帧，此时传来序号为0的帧即认为是重复帧。

- event

协议3中有三种事件

- `frame_arrival`

一帧数据到达接收方然后出发此事件。

- `cksum_err`

  

- `timeout`

  

- 定时器timer

  

## 3.4.2 流水线可靠数据传输协议

协议三的性能瓶颈在于它是一个停等协议。解决方式是改造成流水线的模式，不再等待一个响应。

需要解决的问题：

- 必须增加序号的范围
- 协议的发送接收方必须可以缓存多个分组
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时打的分组。

解决流水线的差错恢复，有两种办法：

- 回退N步
- 选择重传

## 协议4：1位滑动窗口协议

和协议三效果相同。

## 协议5：回退N协议

## **概念**

回退N步（GBN）协议中，允许发送方发送多个分组而不需等待确认，流水线中未确认的分组数不能超过某个最大的允许值N。

  

![](https://pic2.zhimg.com/80/v2-a79aa6c7897e491df96fe9a71ea1eea1_1440w.webp)

  

一个窗口大小为4的例子：

  

![](https://pic2.zhimg.com/80/v2-afb1a2c8c3addd0e10470a927a038659_1440w.webp)

  

> GBN中，接收方丢弃所有失序分组。  
> 滑动窗口指的是发送方窗口的滑动，当发送方接收到连续的ACK时，窗口进行滑动。  
> 超时之后发送所有分组。

## **窗口大小**

窗口大小w选择多大合适呢？

  

![](https://pic3.zhimg.com/80/v2-1fa7353b1437cfca86554f469f2b9bd6_1440w.webp)

  

  

![](https://pic3.zhimg.com/80/v2-723e9a6ab8c6a61669cd93a22ce344e6_1440w.webp)

  

即 。

## 协议6：选择重传协议

## **概念**

解决GBN的性能问题，因为一个分组的失效，必须重传其后所有的分组，效率很低。

选择重传仅重传了有错的分组。

  

![](https://pic3.zhimg.com/80/v2-6c10ec752d1e276959b0ae7e77b0a99a_1440w.webp)

  

> 注意：《计算机网络 第五版》 P181页配图有误。  
> 图b表示选择重传。  
> 接收3分组到后返回NAK是对2分组丢失的回应。在接收到NAK之后，发送方立即重传有问题的分组。接收到分组2之后，返回ACK5的原因是，之前的已经排序好了，发送ACK5提示发送方之前传送的已经没有问题。  
> 这是一种SR的策略。

一个例子。

  

![](https://pic3.zhimg.com/80/v2-bc563d856edfb8e7632a033abd60f84a_1440w.webp)

  

> 这里我们认为，发送方和接收方都有一个窗口，发送方只有接收到ACK回应，才会移动发送窗口；接收方只有最小序号接收到分组，才会向后滑动。  
> 这是另一种SR策略。  
> 值得注意的是，《自顶向下》和《计算机网络》关于SR的论述有不一样的地方，《计算机网络》引入NAK的概念，这也是这一节第一个图的来源原因。

## **窗口长度**

窗口长度必须小于等于序号空间大小的一半。

  

![](https://pic4.zhimg.com/80/v2-3d3723a66faf36347f597cbf18b56213_1440w.webp)

  

> 在这个栗子中，如果只看中间竖面的右侧部分，发现结果是一样的，然而造成这样结果的发送方传递方式却存在歧义。  
> 所以窗口长度不宜过大。

## 3.5 面向连接的运输：TCP

## 3.5.1 TCP连接
TCP连接需要进行相互“握手”，目的是为了确保数据传输的参数。TCP连接提供**点对点**的**全双工**服务。
![](https://pic4.zhimg.com/80/v2-5fa78b02dce6cd30ea249e4a1da49693_1440w.webp)

  

TCP可以从缓存中取出并放入报文段中的数据数量，受限于**最大报文段长度**（MSS）。TCP连接的组成包括：

- 两台主机上的缓存
- 变量
- 与进程连接的套接字

> MSS和MTU各是什么，二者是什么关系？  
> 答案：MSS是TCP最大报文段长度，就是TCP发送数据需要对数据分段时，最大的段的字节数。MTU是最大传输单元，通常由网卡的硬件特性规定，表示通过该网卡传输的数据单元最大的字节数。 MSS要受同一台机器上的MTU限制。比如MTU为1500字节，那么MSS就只能是1460字节，这是因为1460字节的数据在通过网卡向外传输时，会加上20字节的ip头和20字节的tcp头。

## 3.5.2 TCP报文段结构

TCP首部一般为20字节。

  

![](https://pic1.zhimg.com/80/v2-51e4457f6620cea4fe9bbb8626ed6ddc_1440w.webp)

  

- 32bits序号字段，确认号字段

实现可靠数据传输服务。

TCP将数据看成一个无结构的、有序的字节流。

假设主机A通过TCP给主机B发送数据流。

- A隐式的对数据流中的每一个字节编号
- 假设MSS为1000字节
- 数据流的首字节为0号

这个号码就是序号字段。

![](https://pic1.zhimg.com/80/v2-e752ab5066c3b10fb7a07b3ea16eb124_1440w.webp)

  

主机A填充进报文段段确认号，是主机A期望从主机B收到的下一字节的序号。一个例子：

![](https://pic2.zhimg.com/80/v2-b438f55e107d189140d9819cbbabb5d9_1440w.webp)

  

- 16bits接收窗口

用于流量控制，表示接收方愿意接受的字节数量。

## 3.5.3 时间估计

略

## 3.5.4 可靠数据传输

由序号字段和确认字段衍生出来的几个传输确认的例子：

  

![](https://pic1.zhimg.com/80/v2-00a6e8b140191cf75189d97f0173260c_1440w.webp)

  

  

![](https://pic2.zhimg.com/80/v2-b2567244db59ca74fe06086e7b0e1f05_1440w.webp)

  

## 3.5.5 流量控制

TCP通过让发送方维护一个成为接受窗口的变量，来提供流量控制的效果。

## 3.5.6 TCP连接管理

## 建立一个TCP连接

  

![](https://pic4.zhimg.com/80/v2-ca4e7522b39098b897f68f7022dcc3db_1440w.webp)

1.

- 客户端TCP向服务器端TCP发送一个特殊的TCP报文段（被称为**SYN报文段**）

该报文段中不包含应用层数据（实际传输的数据），在首部的一个标识位（即SYN比特）被置为1。

- 客户随机选择一个初始序号（client_isn），将此编号放置于该其实的TCP SYN报文段的**序号字段**中。

2. 

- TCP SYN报文段到达服务器主机，服务器从数据报中提取出TCP SYN报文段，并为其分配TCP缓存与变量（TCP连接建立前分配资源，容易受到**SYN洪泛攻击**）
- 向该TCP客户端发送允许连接的报文段（被称作**SYNACK报文段**），报文段中：

- SYN比特被置为1
- TCP报文首部**确认号字段**被置为 client_isn + 1
- 服务器选择自己的序号server_isn，放入**序号字段**中。

3.

- 收到SYNACK报文段后，客服端分配TCP缓存与变量
- 客户端主机向服务器发送一个报文段

- 将server_isn + 1 作为**确认号字段**
- SYN比特置为0
- **序号字段**为 client_isn + 1
- 可携带需要传输的数据

  

## 拆除一个TCP连接

![](https://pic3.zhimg.com/80/v2-f0796184eb15001d2951142f12d997a6_1440w.webp)

  

参与TCP连接的两端都可以选择终止连接。

1. 客户应用进程想要关闭连接，于是发送一个特殊的TCP报文段。

- 报文段中首部有一个**FIN比特**标识位，被设置为1

2. 服务器收到报文段后，返回一个确认报文段

3. 服务器发送自己的终止报文段

- 报文段中首部有一个**FIN比特**标识位，被设置为1

4. 客户端对终止报文段进行确认
## 3.6-3.7 拥塞控制

详见《RDMA...》那篇论文的解读